#ceg stage monitor  
#use the form from the freeman paper to highlight the contributions of each of the stages.
#' A function to compute the batch monitor of a BN according to the form given in Cowell, et. al. 2007
#'
#' @param rho double of the probability of situations composing stage changing
#' @param t integer ofnumber of records to consider from the data frame
#' @param which.cut integer of the cut that the target stage belongs to
#' @param tgt.stg string recording what stage to examine
#' @param stage.key list of data frames generated by tostagekey()
#' @param stages list of all stages in the staged tree
#' @param df data frame
#' @keywords one step forecast, stage, monitor
#' @export
#' @examples
#' 
rho<-0.9#probability of changing sit contributions
t <- 500 #number of sample size to run 

which.cut <- 3
tgt.stg <- 'u3'
stage.key <- chds.stage.key
stages <- chds.stages

ceg.stage.monitor <- function(rho=0.8,t=500,which.cut, tgt.stg, stage.key,stages, df){
  colnames(df) -> cuts
  stg.idx <- which(stages==tgt.stg)
  
  df.cut <- df[1:30,]
  
  crrnt.sits <- which(stage.key[[which.cut]]$stage == tgt.stg)#the present situations
  all.sits <- 1:dim(stage.key[[which.cut]])[1]
  add.sits <- setdiff(all.sits,crrnt.sits)#extra situations
  
  coarse.sits <- list()
  for(i in 1:length(add.sits)){
    coarse.sits[[i]] <- c(crrnt.sits, add.sits[i])
  } #find the coarser partitions of situations
  fine.sits <- list() #find the finer partitions of situations
  for (i in 1:length(crrnt.sits)){
    fine.sits[[i]]<-crrnt.sits[-i]
  }
  possible.sits <- c(list(crrnt.sits), coarse.sits, fine.sits)#all opts of adding or removing a situation
  
  
  p.trans <- rep(0, length(possible.sits))
  p.trans[1] <- rho; p.trans[2:length(p.trans)] <- (1-rho)/length(p.trans)#create p.trans vector 
  
  alpha <- unlist(prior[stg.idx])
  
  p.monitor <- list()
  for (l in 1:t){
    df.cut <- df[1:l,]
    p2 <- rep(NA, length(possible.sits))
    for (i in 1:length(possible.sits)){
      sit <- unlist(possible.sits[i])
      for (j in 1 :length(unlist(sit))){
        df_cuts[[j]]<- df.cut
        for (k in 1:(which.cut-1)){
          df_cuts[[j]]<-filter(df_cuts[[j]],UQ(sym(colnames(df)[k]))==as.character(unlist(stage.key[[which.cut]][sit[j],k+1])))
        }
      }
      df_imported <-do.call(rbind,df_cuts)
      df_imported %>% count(UQ(sym(colnames(df)[which.cut]))) %>% complete(UQ(sym(colnames(df)[which.cut]))) %>% mutate(n=replace_na(n,0))%>% select(n) -> N
      p2[i]<-sum(lgamma(alpha + N) - lgamma(alpha)) + sum(lgamma(sum(alpha)) - lgamma(sum(alpha + N)))
      
    }
    
    
    p <- exp(p2)/sum(exp(p2)) 
    p.monitor[[l]] <-p*p.trans
    
  }
  return(p.monitor)
}




